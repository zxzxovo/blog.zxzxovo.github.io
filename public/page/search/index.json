[{"content":" 在一些慌忙中做完了必做的准备，整理收集，邮寄或丢弃，离开的准备需要很多体力。我想只需一杯咖啡或者安稳地睡到自然醒，劳累便可缓解许多。不过还有一些东西就像漏水墙壁上潮湿的痕迹，它会悄悄蔓延扩散，到被发觉时早已深深渗了进去。\n分离是很平凡的事，正如相聚一般。我曾喜欢在回忆上施加美好的形容词来总结二者之间的时光。然我自身所成长和我与他人所经历，其意义不必证明。悲喜苦乐只需你知我知，并不足为外人道，这便已是浪漫。很多日子我苦苦纠结于此，后知后觉其实为多余，只有犹豫与不信会磨灭意义。\n在我正告别的这些时光里，我将情绪和直觉用作散列的索引，它是精神行囊的一部分，是无比重要的东西。怀旧可能不能用来描述我，但在此刻我也因过往的逝去而感到忧伤。其实过往早已消逝，此时面前之物的变动终于让我发现了那片空地，而潮湿却已渗入墙壁。\n或许是悔恨。某曾与我谈论落子无悔，但人怎能真切的没有悔意呢。我已无数次想过从前所应做的，无数次对种种过往悲叹，可惜做出的决定不会改变了。悔恨是一种痛苦，但正因痛苦，人才能好好记住，临别时的悔恨也大概如此吧。\n这也是一段生活的结束。我喜欢学猫猫的叫声，当我问自己接下来的生活怎样，喵喵？现在已经没有回应了。收拾东西着实困难，有太多太繁琐的物品和它们的记忆，真希望我能全部带走。这不是我的生活，用“的”形容我与生活的关系并不恰当，我只依托于生活存在，生活是的我收容者。也许未来依旧如此。\n我已在无人时聆听了寂静的声音，在某地落下了几滴泪水，在某时行走过一片土地，在纠结和迷茫后终于正视珍视重视这一切以及自己。\n“人间不过是你无心的梦，偶然留下的梦 尘世梦”。这不是梦，是我不能逃离的一切。\n","date":"2025-07-01T03:52:34+08:00","image":"https://blog.hizhixia.site/post/%E6%88%91%E8%B5%A0%E4%BA%88%E7%A6%BB%E5%88%AB/navigation_hu_5d2d62b9de55c7c2.jpg","permalink":"https://blog.hizhixia.site/post/%E6%88%91%E8%B5%A0%E4%BA%88%E7%A6%BB%E5%88%AB/","title":"我赠予离别"},{"content":" 孤独是一缕烟雾\n它的来路模糊\n去向恍惚\n它在缥缈中由浓而淡\n如初醒的眼眸中\n水彩总是柔软\n花色怎样鲜明\n却留在纱外\n我希望采下那样的一束花\n如烟一般\n在静谧中哀伤\n在凄凉中彷徨\n哪怕只采下一片花瓣\n它将在清晨的薄雾中沉默\n在模糊中安宁，而后\n沾湿黎明的梦\n它要在风中挥舞着烟雾\n","date":"2025-06-29T10:53:46+08:00","image":"https://blog.hizhixia.site/post/%E5%AD%A4%E7%8B%AC%E6%98%AF%E4%B8%80%E7%BC%95%E7%83%9F%E9%9B%BE/navigation_hu_985edcdf4ef74a91.jpg","permalink":"https://blog.hizhixia.site/post/%E5%AD%A4%E7%8B%AC%E6%98%AF%E4%B8%80%E7%BC%95%E7%83%9F%E9%9B%BE/","title":"孤独是一缕烟雾"},{"content":"Android应用开发四大组件详解 Android应用开发中常使用系统提供的 四大组件 ： Activity, Service, Broadcast Receiver, Content Provider。\n近期学习 《Android 第一行代码》，在这里总结一下四大组件的基础用法，用以巩固。\n部分代码使用AI生成。\nAndroid应用工作原理 应用启动流程 Android应用程序 启动 的过程与PC略有不同。在Android设备上，当用户在Launcher（桌面）点击应用图标时：\nLauncher发起请求：Launcher会将启动该应用所需的相关信息发送给 AMS(ActivityManagerService) AMS处理请求：AMS经过一系列检查和处理后，会根据该应用的进程是否已经存在来决定要创建一个新的应用进程还是在已有进程中直接启动Activity 进程创建：如需要新进程，由Zygote进程fork出新的应用进程 Activity启动：在应用进程中创建Activity实例并启动 Android系统架构 Android系统采用分层架构：\n应用层(Application)：各种应用程序 应用框架层(Framework)：提供四大组件等API 系统运行库层：核心库和ART虚拟机 Linux内核层：驱动程序和系统服务 Activity Activity 是Android应用中 最基本 的组件，负责提供用户界面和处理用户交互。每个Activity都代表一个单独的屏幕页面。\nActivity生命周期 Activity拥有完整的生命周期：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // onCreate在 A ctivity被创建时调用，用于初始化工作 Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onCreate\u0026#34;) } override fun onStart() { super.onStart() // Activity变为可见时调用 Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onStart\u0026#34;) } override fun onResume() { super.onResume() // Activity获得焦点，用户可以与之交互 Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onResume\u0026#34;) } override fun onPause() { super.onPause() // Activity失去焦点，但仍可见 Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onPause\u0026#34;) } override fun onStop() { super.onStop() // Activity不可见时调用 Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onStop\u0026#34;) } override fun onDestroy() { super.onDestroy() // Activity被销毁时调用，释放资源 Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onDestroy\u0026#34;) } override fun onRestart() { super.onRestart() // Activity从停止状态重新启动时调用 Log.d(\u0026#34;Activity\u0026#34;, \u0026#34;onRestart\u0026#34;) } } Activity创建和使用 1. 创建Activity类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class SecondActivity : AppCompatActivity() { companion object { const val REQUEST_CODE = 1001 } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_second) // 获取传递的数据 val data = intent.getStringExtra(\u0026#34;key_data\u0026#34;) val number = intent.getIntExtra(\u0026#34;key_number\u0026#34;, 0) Log.d(\u0026#34;SecondActivity\u0026#34;, \u0026#34;接收到数据: $data, 数字: $number\u0026#34;) // 设置返回结果 findViewById\u0026lt;Button\u0026gt;(R.id.btn_return).setOnClickListener { val resultIntent = Intent().apply { putExtra(\u0026#34;result_data\u0026#34;, \u0026#34;返回的数据\u0026#34;) } setResult(RESULT_OK, resultIntent) finish() } } } 2. 在AndroidManifest.xml中注册 1 2 3 4 \u0026lt;activity android:name=\u0026#34;.SecondActivity\u0026#34; android:label=\u0026#34;第二个页面\u0026#34; android:theme=\u0026#34;@style/AppTheme\u0026#34; /\u0026gt; 3. Activity间跳转和数据传递 显式Intent启动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MainActivity : AppCompatActivity() { companion object { const val REQUEST_CODE = 1001 } private fun basicJump() { // 基本跳转 val intent = Intent(this, SecondActivity::class.java) startActivity(intent) } private fun jumpWithData() { // 携带数据跳转 val intent = Intent(this, SecondActivity::class.java).apply { putExtra(\u0026#34;key_data\u0026#34;, \u0026#34;传递的字符串\u0026#34;) putExtra(\u0026#34;key_number\u0026#34;, 123) } startActivity(intent) } private fun jumpForResult() { // 期望返回结果的跳转 val intent = Intent(this, SecondActivity::class.java) startActivityForResult(intent, REQUEST_CODE) } } 隐式Intent启动：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 private fun implicitIntents() { // 启动浏览器 val webIntent = Intent(Intent.ACTION_VIEW).apply { data = Uri.parse(\u0026#34;https://www.google.com\u0026#34;) } startActivity(webIntent) // 拨打电话 val dialIntent = Intent(Intent.ACTION_DIAL).apply { data = Uri.parse(\u0026#34;tel:10086\u0026#34;) } startActivity(dialIntent) // 发送邮件 val emailIntent = Intent(Intent.ACTION_SENDTO).apply { data = Uri.parse(\u0026#34;mailto:example@gmail.com\u0026#34;) putExtra(Intent.EXTRA_SUBJECT, \u0026#34;邮件主题\u0026#34;) putExtra(Intent.EXTRA_TEXT, \u0026#34;邮件内容\u0026#34;) } startActivity(emailIntent) } 4. 处理Activity返回结果 传统方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { REQUEST_CODE -\u0026gt; { if (resultCode == RESULT_OK) { val result = data?.getStringExtra(\u0026#34;result_data\u0026#34;) Log.d(\u0026#34;MainActivity\u0026#34;, \u0026#34;收到返回结果: $result\u0026#34;) // 处理返回的数据 } } } } 使用Activity Result API（推荐）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MainActivity : AppCompatActivity() { // 注册Activity Result Launcher private val startActivityLauncher = registerForActivityResult( ActivityResultContracts.StartActivityForResult() ) { result -\u0026gt; if (result.resultCode == RESULT_OK) { val data = result.data?.getStringExtra(\u0026#34;result_data\u0026#34;) Log.d(\u0026#34;MainActivity\u0026#34;, \u0026#34;收到返回结果: $data\u0026#34;) } } private fun launchSecondActivity() { val intent = Intent(this, SecondActivity::class.java) startActivityLauncher.launch(intent) } } Activity启动模式 在AndroidManifest.xml中可以设置Activity的启动模式：\n1 2 3 \u0026lt;activity android:name=\u0026#34;.MainActivity\u0026#34; android:launchMode=\u0026#34;singleTop\u0026#34; /\u0026gt; standard：默认模式，每次启动都创建新实例 singleTop：如果Activity在栈顶，则复用实例 singleTask：栈内只保留一个实例 singleInstance：单独占用一个任务栈 Service Service 是Android中用于执行 后台任务 的组件，即应用程序界面并没有显示时，Service仍可以在后台持续运行(Android 8.0之后对后台的限制进一步加强，可以使用Jetpack Workmanager进行管理)。 需要注意的是Service默认还是 在主线程 执行的。 Srvice主要有两种启动方式：\n启动式Service (Started Service) 通过startService()启动，适用于执行单一操作且不需要返回结果的场景。\n基本使用步骤：\n创建Service类，继承自Service 重写onStartCommand()方法 在AndroidManifest.xml中注册 使用startService()启动 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class MyService : Service() { override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { // 执行后台任务 Thread { try { // 模拟耗时操作 Thread.sleep(5000) Log.d(\u0026#34;MyService\u0026#34;, \u0026#34;任务执行完成\u0026#34;) stopSelf() // 任务完成后停止服务 } catch (e: InterruptedException) { e.printStackTrace() } }.start() return START_STICKY // 服务被杀死后会重新创建 } override fun onBind(intent: Intent?): IBinder? { return null // 启动式服务返回null } override fun onCreate() { super.onCreate() Log.d(\u0026#34;MyService\u0026#34;, \u0026#34;服务被创建\u0026#34;) } override fun onDestroy() { super.onDestroy() Log.d(\u0026#34;MyService\u0026#34;, \u0026#34;服务被销毁\u0026#34;) } } // 在Activity中启动Service class MainActivity : AppCompatActivity() { private fun startMyService() { val intent = Intent(this, MyService::class.java) startService(intent) } private fun stopMyService() { val intent = Intent(this, MyService::class.java) stopService(intent) } } 绑定式Service (Bound Service) 通过bindService()启动，适用于需要与Activity进行交互的场景。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class MyBoundService : Service() { inner class LocalBinder : Binder() { fun getService(): MyBoundService = this@MyBoundService } private val binder = LocalBinder() override fun onBind(intent: Intent?): IBinder = binder // 提供给客户端调用的方法 fun getCurrentTime(): String = Date().toString() fun performCalculation(a: Int, b: Int): Int = a + b override fun onCreate() { super.onCreate() Log.d(\u0026#34;MyBoundService\u0026#34;, \u0026#34;绑定式服务创建\u0026#34;) } override fun onDestroy() { super.onDestroy() Log.d(\u0026#34;MyBoundService\u0026#34;, \u0026#34;绑定式服务销毁\u0026#34;) } } // 在Activity中绑定Service class MainActivity : AppCompatActivity() { private var boundService: MyBoundService? = null private var isBound = false private val connection = object : ServiceConnection { override fun onServiceConnected(name: ComponentName?, service: IBinder?) { val binder = service as MyBoundService.LocalBinder boundService = binder.getService() isBound = true // 可以调用服务的方法 val time = boundService?.getCurrentTime() val result = boundService?.performCalculation(10, 20) Log.d(\u0026#34;MainActivity\u0026#34;, \u0026#34;当前时间: $time, 计算结果: $result\u0026#34;) } override fun onServiceDisconnected(name: ComponentName?) { isBound = false boundService = null } } private fun bindMyService() { val intent = Intent(this, MyBoundService::class.java) bindService(intent, connection, BIND_AUTO_CREATE) } private fun unbindMyService() { if (isBound) { unbindService(connection) isBound = false } } override fun onDestroy() { super.onDestroy() unbindMyService() } } 前台Service（Foreground Service） 用于执行用户可感知的任务，需要显示持续通知：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class ForegroundService : Service() { companion object { const val CHANNEL_ID = \u0026#34;ForegroundServiceChannel\u0026#34; const val NOTIFICATION_ID = 1 } override fun onCreate() { super.onCreate() createNotificationChannel() } override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { val notification = createNotification() startForeground(NOTIFICATION_ID, notification) // 执行长时间运行的任务 performLongRunningTask() return START_STICKY } override fun onBind(intent: Intent?): IBinder? = null private fun createNotificationChannel() { if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.O) { val channel = NotificationChannel( CHANNEL_ID, \u0026#34;前台服务通道\u0026#34;, NotificationManager.IMPORTANCE_LOW ) val manager = getSystemService(NotificationManager::class.java) manager.createNotificationChannel(channel) } } private fun createNotification(): Notification { return NotificationCompat.Builder(this, CHANNEL_ID) .setContentTitle(\u0026#34;前台服务运行中\u0026#34;) .setContentText(\u0026#34;正在执行后台任务...\u0026#34;) .setSmallIcon(R.drawable.ic_notification) .build() } private fun performLongRunningTask() { Thread { // 执行耗时任务 for (i in 1..100) { Thread.sleep(1000) Log.d(\u0026#34;ForegroundService\u0026#34;, \u0026#34;任务进度: $i%\u0026#34;) } stopSelf() }.start() } } Broadcast Receiver Broadcast Receiver用于接收来自系统或其他应用的 广播消息，是Android中实现组件间通信的重要方式。\n广播类型 标准广播：异步执行，所有接收器几乎同时收到 有序广播：同步执行，按优先级依次传递，可被拦截 本地广播：仅在应用内部传播，更安全高效 注册方式 静态注册 在AndroidManifest.xml中注册，应用未启动也能接收广播：\n1 2 3 4 5 6 \u0026lt;receiver android:name=\u0026#34;.MyBroadcastReceiver\u0026#34;\u0026gt; \u0026lt;intent-filter android:priority=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;action android:name=\u0026#34;android.intent.action.BOOT_COMPLETED\u0026#34;/\u0026gt; \u0026lt;action android:name=\u0026#34;com.example.MY_BROADCAST\u0026#34;/\u0026gt; \u0026lt;/intent-filter\u0026gt; \u0026lt;/receiver\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyBroadcastReceiver : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { when (intent?.action) { Intent.ACTION_BOOT_COMPLETED -\u0026gt; { Log.d(\u0026#34;Receiver\u0026#34;, \u0026#34;系统启动完成\u0026#34;) } \u0026#34;com.example.MY_BROADCAST\u0026#34; -\u0026gt; { val data = intent.getStringExtra(\u0026#34;data\u0026#34;) Log.d(\u0026#34;Receiver\u0026#34;, \u0026#34;收到自定义广播: $data\u0026#34;) } Intent.ACTION_BATTERY_LOW -\u0026gt; { Log.d(\u0026#34;Receiver\u0026#34;, \u0026#34;电量低\u0026#34;) } Intent.ACTION_SCREEN_ON -\u0026gt; { Log.d(\u0026#34;Receiver\u0026#34;, \u0026#34;屏幕点亮\u0026#34;) } } } } 动态注册 在代码中注册，生命周期与注册组件相同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class MainActivity : AppCompatActivity() { private lateinit var receiver: MyBroadcastReceiver override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) // 创建广播接收器 receiver = MyBroadcastReceiver() // 注册广播接收器 val filter = IntentFilter().apply { addAction(\u0026#34;com.example.MY_BROADCAST\u0026#34;) addAction(Intent.ACTION_BATTERY_CHANGED) priority = 100 // 设置优先级 } registerReceiver(receiver, filter) // 设置发送广播按钮 findViewById\u0026lt;Button\u0026gt;(R.id.btn_send_broadcast).setOnClickListener { sendCustomBroadcast() } } override fun onDestroy() { super.onDestroy() unregisterReceiver(receiver) // 记得取消注册 } private fun sendCustomBroadcast() { val intent = Intent(\u0026#34;com.example.MY_BROADCAST\u0026#34;).apply { putExtra(\u0026#34;data\u0026#34;, \u0026#34;来自MainActivity的数据\u0026#34;) } sendBroadcast(intent) } } 发送广播 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class BroadcastSender : AppCompatActivity() { private fun sendBroadcasts() { // 发送标准广播 val standardIntent = Intent(\u0026#34;com.example.MY_BROADCAST\u0026#34;).apply { putExtra(\u0026#34;data\u0026#34;, \u0026#34;标准广播数据\u0026#34;) putExtra(\u0026#34;timestamp\u0026#34;, System.currentTimeMillis()) } sendBroadcast(standardIntent) // 发送有序广播 val orderedIntent = Intent(\u0026#34;com.example.ORDERED_BROADCAST\u0026#34;).apply { putExtra(\u0026#34;data\u0026#34;, \u0026#34;有序广播数据\u0026#34;) } sendOrderedBroadcast(orderedIntent, null) // 发送本地广播（仅应用内部接收） val localIntent = Intent(\u0026#34;com.example.LOCAL_BROADCAST\u0026#34;).apply { putExtra(\u0026#34;data\u0026#34;, \u0026#34;本地广播数据\u0026#34;) } LocalBroadcastManager.getInstance(this).sendBroadcast(localIntent) } // 发送带权限的广播 private fun sendProtectedBroadcast() { val intent = Intent(\u0026#34;com.example.PROTECTED_BROADCAST\u0026#34;) sendBroadcast(intent, \u0026#34;com.example.CUSTOM_PERMISSION\u0026#34;) } } 有序广播处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class OrderedBroadcastReceiver : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { when (intent?.action) { \u0026#34;com.example.ORDERED_BROADCAST\u0026#34; -\u0026gt; { val data = intent.getStringExtra(\u0026#34;data\u0026#34;) Log.d(\u0026#34;OrderedReceiver\u0026#34;, \u0026#34;接收到有序广播: $data\u0026#34;) // 可以修改结果数据 resultData = \u0026#34;处理后的数据\u0026#34; // 可以终止广播传递（阻止后续接收器接收） // abortBroadcast() // 设置结果给下一个接收器 setResult(Activity.RESULT_OK, \u0026#34;新的数据\u0026#34;, null) } } } } Content Provider Content Provider是Android中实现 跨应用数据共享 的标准方式，当你想访问其他应用程序提供的数据(如通讯录中的联系人)时，就需要使用该组件。\n主要特点 提供统一的数据访问接口 支持增删改查(CRUD)操作 使用URI来标识数据 自动处理跨进程通信 基本使用 创建Content Provider 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class MyContentProvider : ContentProvider() { companion object { private const val AUTHORITY = \u0026#34;com.example.provider\u0026#34; private const val USER_DIR = 0 private const val USER_ITEM = 1 private val uriMatcher = UriMatcher(UriMatcher.NO_MATCH).apply { addURI(AUTHORITY, \u0026#34;users\u0026#34;, USER_DIR) addURI(AUTHORITY, \u0026#34;users/#\u0026#34;, USER_ITEM) } } private lateinit var dbHelper: MyDatabaseHelper override fun onCreate(): Boolean { dbHelper = MyDatabaseHelper(context, \u0026#34;MyApp.db\u0026#34;, null, 1) return true } override fun query( uri: Uri, projection: Array\u0026lt;out String\u0026gt;?, selection: String?, selectionArgs: Array\u0026lt;out String\u0026gt;?, sortOrder: String? ): Cursor? { val db = dbHelper.readableDatabase return when (uriMatcher.match(uri)) { USER_DIR -\u0026gt; { db.query(\u0026#34;users\u0026#34;, projection, selection, selectionArgs, null, null, sortOrder) } USER_ITEM -\u0026gt; { val userId = uri.pathSegments[1] db.query(\u0026#34;users\u0026#34;, projection, \u0026#34;id = ?\u0026#34;, arrayOf(userId), null, null, sortOrder) } else -\u0026gt; null } } override fun insert(uri: Uri, values: ContentValues?): Uri? { val db = dbHelper.writableDatabase return when (uriMatcher.match(uri)) { USER_DIR -\u0026gt; { val newUserId = db.insert(\u0026#34;users\u0026#34;, null, values) val newUri = Uri.parse(\u0026#34;content://$AUTHORITY/users/$newUserId\u0026#34;) // 通知数据变化 context?.contentResolver?.notifyChange(uri, null) newUri } else -\u0026gt; null } } override fun delete(uri: Uri, selection: String?, selectionArgs: Array\u0026lt;out String\u0026gt;?): Int { val db = dbHelper.writableDatabase val deletedRows = when (uriMatcher.match(uri)) { USER_DIR -\u0026gt; { db.delete(\u0026#34;users\u0026#34;, selection, selectionArgs) } USER_ITEM -\u0026gt; { val userId = uri.pathSegments[1] db.delete(\u0026#34;users\u0026#34;, \u0026#34;id = ?\u0026#34;, arrayOf(userId)) } else -\u0026gt; 0 } if (deletedRows \u0026gt; 0) { context?.contentResolver?.notifyChange(uri, null) } return deletedRows } override fun update( uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array\u0026lt;out String\u0026gt;? ): Int { val db = dbHelper.writableDatabase val updatedRows = when (uriMatcher.match(uri)) { USER_DIR -\u0026gt; { db.update(\u0026#34;users\u0026#34;, values, selection, selectionArgs) } USER_ITEM -\u0026gt; { val userId = uri.pathSegments[1] db.update(\u0026#34;users\u0026#34;, values, \u0026#34;id = ?\u0026#34;, arrayOf(userId)) } else -\u0026gt; 0 } if (updatedRows \u0026gt; 0) { context?.contentResolver?.notifyChange(uri, null) } return updatedRows } override fun getType(uri: Uri): String? { return when (uriMatcher.match(uri)) { USER_DIR -\u0026gt; \u0026#34;vnd.android.cursor.dir/vnd.com.example.provider.users\u0026#34; USER_ITEM -\u0026gt; \u0026#34;vnd.android.cursor.item/vnd.com.example.provider.users\u0026#34; else -\u0026gt; null } } } 数据库帮助类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class MyDatabaseHelper( context: Context?, name: String?, factory: SQLiteDatabase.CursorFactory?, version: Int ) : SQLiteOpenHelper(context, name, factory, version) { companion object { private const val CREATE_USERS = \u0026#34;\u0026#34;\u0026#34; CREATE TABLE users ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, age INTEGER NOT NULL, email TEXT ) \u0026#34;\u0026#34;\u0026#34; } override fun onCreate(db: SQLiteDatabase?) { db?.execSQL(CREATE_USERS) } override fun onUpgrade(db: SQLiteDatabase?, oldVersion: Int, newVersion: Int) { db?.execSQL(\u0026#34;DROP TABLE IF EXISTS users\u0026#34;) onCreate(db) } } 在AndroidManifest.xml中注册 1 2 3 4 \u0026lt;provider android:name=\u0026#34;.MyContentProvider\u0026#34; android:authorities=\u0026#34;com.example.provider\u0026#34; android:exported=\u0026#34;true\u0026#34; /\u0026gt; 访问Content Provider 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 class ContentProviderClient : AppCompatActivity() { private val userUri = Uri.parse(\u0026#34;content://com.example.provider/users\u0026#34;) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_content_provider_client) setupButtons() } private fun setupButtons() { findViewById\u0026lt;Button\u0026gt;(R.id.btn_query).setOnClickListener { queryUsers() } findViewById\u0026lt;Button\u0026gt;(R.id.btn_insert).setOnClickListener { insertUser() } findViewById\u0026lt;Button\u0026gt;(R.id.btn_update).setOnClickListener { updateUser() } findViewById\u0026lt;Button\u0026gt;(R.id.btn_delete).setOnClickListener { deleteUser() } } private fun queryUsers() { val cursor = contentResolver.query(userUri, null, null, null, null) cursor?.use { while (it.moveToNext()) { val id = it.getInt(it.getColumnIndexOrThrow(\u0026#34;id\u0026#34;)) val name = it.getString(it.getColumnIndexOrThrow(\u0026#34;name\u0026#34;)) val age = it.getInt(it.getColumnIndexOrThrow(\u0026#34;age\u0026#34;)) val email = it.getString(it.getColumnIndexOrThrow(\u0026#34;email\u0026#34;)) Log.d(\u0026#34;ContentProvider\u0026#34;, \u0026#34;用户: ID=$id, 姓名=$name, 年龄=$age, 邮箱=$email\u0026#34;) } } } private fun insertUser() { val values = ContentValues().apply { put(\u0026#34;name\u0026#34;, \u0026#34;张三\u0026#34;) put(\u0026#34;age\u0026#34;, 25) put(\u0026#34;email\u0026#34;, \u0026#34;zhangsan@example.com\u0026#34;) } val newUri = contentResolver.insert(userUri, values) Log.d(\u0026#34;ContentProvider\u0026#34;, \u0026#34;插入用户成功，URI: $newUri\u0026#34;) } private fun updateUser() { val values = ContentValues().apply { put(\u0026#34;age\u0026#34;, 26) put(\u0026#34;email\u0026#34;, \u0026#34;zhangsan_new@example.com\u0026#34;) } val updatedRows = contentResolver.update( userUri, values, \u0026#34;name = ?\u0026#34;, arrayOf(\u0026#34;张三\u0026#34;) ) Log.d(\u0026#34;ContentProvider\u0026#34;, \u0026#34;更新了 $updatedRows 行数据\u0026#34;) } private fun deleteUser() { val deletedRows = contentResolver.delete( userUri, \u0026#34;name = ?\u0026#34;, arrayOf(\u0026#34;张三\u0026#34;) ) Log.d(\u0026#34;ContentProvider\u0026#34;, \u0026#34;删除了 $deletedRows 行数据\u0026#34;) } // 监听数据变化 private val contentObserver = object : ContentObserver(Handler(Looper.getMainLooper())) { override fun onChange(selfChange: Boolean) { super.onChange(selfChange) Log.d(\u0026#34;ContentProvider\u0026#34;, \u0026#34;数据发生变化\u0026#34;) queryUsers() // 重新查询数据 } } override fun onStart() { super.onStart() // 注册内容观察者 contentResolver.registerContentObserver(userUri, true, contentObserver) } override fun onStop() { super.onStop() // 取消注册内容观察者 contentResolver.unregisterContentObserver(contentObserver) } } 访问系统Content Provider 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class SystemContentProviderExample : AppCompatActivity() { private fun accessContacts() { // 访问联系人 val contactsUri = ContactsContract.CommonDataKinds.Phone.CONTENT_URI val projection = arrayOf( ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME, ContactsContract.CommonDataKinds.Phone.NUMBER ) val cursor = contentResolver.query(contactsUri, projection, null, null, null) cursor?.use { while (it.moveToNext()) { val name = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)) val number = it.getString(it.getColumnIndexOrThrow(ContactsContract.CommonDataKinds.Phone.NUMBER)) Log.d(\u0026#34;Contacts\u0026#34;, \u0026#34;联系人: $name, 电话: $number\u0026#34;) } } } private fun accessMediaFiles() { // 访问媒体文件 val mediaUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI val projection = arrayOf( MediaStore.Images.Media._ID, MediaStore.Images.Media.DISPLAY_NAME, MediaStore.Images.Media.SIZE ) val cursor = contentResolver.query(mediaUri, projection, null, null, null) cursor?.use { while (it.moveToNext()) { val id = it.getLong(it.getColumnIndexOrThrow(MediaStore.Images.Media._ID)) val name = it.getString(it.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)) val size = it.getLong(it.getColumnIndexOrThrow(MediaStore.Images.Media.SIZE)) Log.d(\u0026#34;Media\u0026#34;, \u0026#34;图片: ID=$id, 名称=$name, 大小=$size\u0026#34;) } } } } 总结 Android四大组件构成了Android应用的核心架构：\nActivity：负责用户界面的展示和交互，是用户能看到和操作的页面 Service：处理后台任务和长时间运行的操作，即使应用不在前台也能工作 Broadcast Receiver：实现组件间的消息通信，监听系统和应用事件 Content Provider：提供跨应用的数据共享机制，统一数据访问接口 组件间协作示例 在实际开发中，四大组件经常需要协同工作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 class ComponentCollaborationExample : AppCompatActivity() { private lateinit var downloadReceiver: BroadcastReceiver override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_collaboration) setupBroadcastReceiver() findViewById\u0026lt;Button\u0026gt;(R.id.btn_start_download).setOnClickListener { startDownload() } } private fun setupBroadcastReceiver() { // 注册下载完成广播接收器 downloadReceiver = object : BroadcastReceiver() { override fun onReceive(context: Context?, intent: Intent?) { when (intent?.action) { \u0026#34;com.example.DOWNLOAD_COMPLETE\u0026#34; -\u0026gt; { val fileName = intent.getStringExtra(\u0026#34;file_name\u0026#34;) val filePath = intent.getStringExtra(\u0026#34;file_path\u0026#34;) // 更新UI updateDownloadUI(fileName) // 通过ContentProvider保存文件信息 saveFileInfo(fileName, filePath) } } } } val filter = IntentFilter(\u0026#34;com.example.DOWNLOAD_COMPLETE\u0026#34;) registerReceiver(downloadReceiver, filter) } private fun startDownload() { // Activity启动Service执行下载任务 val serviceIntent = Intent(this, DownloadService::class.java).apply { putExtra(\u0026#34;download_url\u0026#34;, \u0026#34;https://example.com/file.zip\u0026#34;) } startService(serviceIntent) } private fun updateDownloadUI(fileName: String?) { // 更新UI显示下载完成 findViewById\u0026lt;TextView\u0026gt;(R.id.tv_status).text = \u0026#34;下载完成: $fileName\u0026#34; } private fun saveFileInfo(fileName: String?, filePath: String?) { // 通过ContentProvider保存下载的文件信息 val values = ContentValues().apply { put(\u0026#34;file_name\u0026#34;, fileName) put(\u0026#34;file_path\u0026#34;, filePath) put(\u0026#34;download_time\u0026#34;, System.currentTimeMillis()) } val uri = Uri.parse(\u0026#34;content://com.example.provider/files\u0026#34;) contentResolver.insert(uri, values) } override fun onDestroy() { super.onDestroy() unregisterReceiver(downloadReceiver) } } // 下载服务 class DownloadService : Service() { override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { val downloadUrl = intent?.getStringExtra(\u0026#34;download_url\u0026#34;) Thread { // 模拟下载过程 Thread.sleep(3000) // 下载完成后发送广播 val broadcastIntent = Intent(\u0026#34;com.example.DOWNLOAD_COMPLETE\u0026#34;).apply { putExtra(\u0026#34;file_name\u0026#34;, \u0026#34;downloaded_file.zip\u0026#34;) putExtra(\u0026#34;file_path\u0026#34;, \u0026#34;/storage/downloads/downloaded_file.zip\u0026#34;) } sendBroadcast(broadcastIntent) stopSelf() }.start() return START_NOT_STICKY } override fun onBind(intent: Intent?): IBinder? = null } ","date":"2025-06-21T14:54:32+08:00","image":"https://blog.hizhixia.site/post/android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/nav.svg","permalink":"https://blog.hizhixia.site/post/android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","title":"Android四大组件基础"},{"content":" 宁静湖面的倒影\n是夜空沉默的星辰\n你在水面铺上石子\n让严肃的风为我的无措刺身\n我站在无倚的独木望向月亮\n将拾起的花瓣高高捧起\n而后，洒落\n与绕指的兰香在星空中飘荡\n你尚不能把我救赎\n又如何希望我来拯救你\n将你自阴冷的潭水中拉出\n给你阳光一样纯白又冷酷的心\n而我不能拯救你\n我甚至不能拯救我自己\n我只在夜晚看着月亮\n看它在另一片时空反射太阳的光\n我只愿如这花瓣一样\n","date":"2025-05-10T08:32:42+08:00","image":"https://blog.hizhixia.site/post/%E6%9C%88%E5%A4%9C/navigation_hu_6883320f42c46505.jpg","permalink":"https://blog.hizhixia.site/post/%E6%9C%88%E5%A4%9C/","title":"月夜"},{"content":" 你知道的，人应该是有名字的。\n当你在人群中想要与谁交流，或者是传达信息时，你便叫出他的名字。或是使用文字时，你可以写上某个名字，这样你所希望的对象便能知道这是关于他的。名字是有这样的意义吧，能起到在人海中唤出某人的作用，也能为某个包含众多特质的有机生命体打上一个索引标签。\n人的感情是能作用在许多事物上的，当然也包括名字。在大多数情况下，你的名字应该不是自己取的，那么，为你命名的人又是如何看待你的名字？名字是社会默认的，关于它的问题涉及到某些古老难缠的事情，绝不会有许多人喜欢。\n但她没有名字。\n准确地说，她觉得自己并不需要。在她脑海里最初的一些记忆中，有人总是对着她发出一些不明的音节，后来她知道了，这是用她最熟悉的语言表达出的她的名字。这种事情新奇又好玩，她知道，听到这些音节就表明有人要从什么地方过来找自己了。\n直到之后进入学校。她记得是在某天清晨哪节课上，太阳刚刚睡醒就很精神了，刺眼的光穿透彩钢瓦修建的教室的窗户，在砖头铺成的地板蒸腾起的尘土中散射，一条条透亮的光束把书钉在高高的桌子上。她喜欢新的东西，她的书也是新的，但此时书白花花的太亮了，于是就把它扯到一旁，让光束照在木头桌子上。她趴在上面，把脸放在凉凉的桌子上，两只手紧紧贴在桌面，像是在坑洼的小地图上围起了自己的一块领地。大人总是给自己穿很多的衣服，尽管她已经表示自己很热，但他们仍害怕她着凉。于是她喜欢上了摸凉凉的东西，桌子，窗户，书包，摸着会很舒服。\n老师常说喜欢她这样聪明的小孩，她脑海中有着如彩色泡泡般的奇妙想法，但这样的精彩别人却是怎么也没有办法看到的。她仍在这样小的房子里，但却已经在想象的宇宙任性地遨游了。直到老师问起，“你们知道自己的名字吗？”\n她想，我当然知道。马上，她就使用匮乏的的文字知识编出了几句话。\n我的眼睛和鼻子，\n我的耳朵和嘴巴，\n我的左手和右手，\n最后还有我的名字。\n这些都是我的！\n眼睛是用来看的，嘴巴是用来吃饭的，用手可以写字，那名字是干什么的呢？她觉得名字很有趣，但想了好久，也没有想清楚她能拿自己的名字干什么。到最后，她只记得反正名字很有用就是了。\n彩钢瓦房的房顶上会掉下来一些不一样的东西，有时候是白白的冰冰凉凉的东西，她知道这是雪，有时是绿绿的长条，她听老师说这是夏天的柳叶，被风吹上了房顶，又被吹了下来。雪与树叶轮番自屋顶上落下，交替了不知多少回，直到她离开了这些方块似的小房子，去到了水泥做的大楼房。\n这次换了不同的人问出了差不多的问题，“自我介绍一下吧，你们的名字都是什么？”\n我的名字是什么？眼睛是用来看的，嘴巴是用来吃饭的，那名字是干什么的呢？她发现，好像并不能用名字来做些什么。我知道我的眼睛，我的嘴巴，我的手，但我不知道我的名字，或许因为它并不像这些东西一样真切的属于我。名字不属于自己，而属于其他人，它不过是最简单的一个标记。我并不用了解自己的名字，而别人却试图用名字了解我。她想问，自己是如此复杂且丰富的一个生命体，或者只是几个字组成的名字而已。\n时间的流动镌刻着的记忆已经汇为一片汪洋，其中不乏快乐的时刻。“如果我们没有遭受痛苦，又不觉得生活枯燥，世上快乐的必要条件都已经达到了，其他一切都是虚妄的”。然而时光无论具有怎样的主题，都是会被落在身后的。不止如此，还有落下的人，有时只能通过名字回忆。\n她感觉脸上的肌肉有些僵硬，眼睛有一些酸，凉凉的后背突然有些刺痛。\n“同学到你了，你叫什么名字。”\n","date":"2025-04-23T10:17:00+08:00","image":"https://blog.hizhixia.site/post/%E6%9F%90%E4%BA%9B%E6%B4%81%E7%99%96/navigation_hu_7eb793109994efb1.jpg","permalink":"https://blog.hizhixia.site/post/%E6%9F%90%E4%BA%9B%E6%B4%81%E7%99%96/","title":"某些洁癖"},{"content":"2025年4月7日 我写过很多总结性的文字，多数都以“一路走到现在”之类的句子开头或结尾。而我熟知的人在生活中不断遇到新问题时，我面临的是没有改变过的问题。我与某人路上交谈甚久，他越走越远，我却停在原地。\n我因何原因会是现在这种状况？ 因为我出身低微吗，因为我见识短浅吗，因为别人干扰吗？那我要怪罪于家庭学校政府社会乃至整个世界？ 那别人如我般生活又该如何？显然不会跟我相同。因为我就是个只会玩弄无聊把戏的废物蠢货垃圾。\n这就是睡不着的原因了，一个垃圾睡觉能有什么用。什么都干不好，根本不配得到夜晚的安宁入睡。 啊，我只能找些东西让我的情绪波动起来，遮掩对自己的讨厌嫌弃，来换取没有知觉的睡眠。 真的睡不着啊\n2 2025年4月17日 我应该了解我自己。\n我读书时，会在现有的对其所述的理解上继续思考记忆以扩充知识。 如今我浮躁不能平静且记忆衰退。那么我应该通过实践来减轻浮躁，通过重复来加强记忆。 似乎应该每隔一段时间就重新认识自己，来解答我能做什么和我应怎样做的问题\n3 2025年4月18日 突然意识到，我是个很容易被别人影响的人。\n之前以为，我做事时不习惯旁边有人，是因为胆小社恐。现在看来，其实是害怕被别人的话语影响，心底没有自信。如果有人质询指点，我第一反应是顺着对方的话或按对方的指示走，自主的想法却完全丢掉了，而旁人其实是不如本人了解正做的事的信息的。\n","date":"2025-04-20T11:15:21+08:00","image":"https://blog.hizhixia.site/post/%E8%A7%A3%E6%9E%84%E4%B9%8B%E4%BA%8C/navigation_hu_637ce887b3dd736a.jpg","permalink":"https://blog.hizhixia.site/post/%E8%A7%A3%E6%9E%84%E4%B9%8B%E4%BA%8C/","title":"解构之二"},{"content":"本节参考：\nRust语言圣经 RF-闭包表达式 RF-闭包类型 Rust中的闭包与关键字Move Rust有很多对函数式编程的支持，主要有：\n模式匹配 枚举 迭代器 闭包 使用 闭包（Closure） 可以做到 将一系列语句和表达式 赋值给某个变量，因此 这一堆语句和表达式 就可以作为变量，被当作参数传递进函数，或者作为函数返回值返回，这是闭包最明显的特征。闭包的使用很简单，但Rust的闭包不像 JS, Python 中的一样，由于语言特性，它有一些额外需要掌握的细节。 下面将从 闭包如何捕获环境 ， 闭包如何使用捕获值 ，以及 闭包的实现 的角度来介绍闭包。\n开始——捕获环境 Rust中的函数是无法“捕获环境”的。这一特性意味着，对于以下代码：\n1 2 3 4 5 6 7 fn main() { let num = 0; println!(\u0026#34;{num}\u0026#34;); fn func() { println!(\u0026#34;{num}\u0026#34;); } } 即使函数 func() 定义在 main() 内部，它仍然无法直接访问到 main() 中定义的变量。若要访问这些变量，只能通过传递函数参数的方式。需要注意，static 和 const 方式定义的变量具有静态生命周期，是可以访问的。\n而闭包则可以做到捕获环境。\n那么如何定义一个闭包呢？Rust中通过闭包表达式定义一个闭包类型，在其他语言中也称为 lambda表达式。\n闭包表达式的句法规则是：可选的 move ，后跟由 || 包围的参数模式列表（可以省略类型标注），后跟可选的返回值标注 -\u0026gt; type ，后跟一个块表达式（无返回值标注时，若块内只有一个表达式则可以直接写在 || 后）。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn main() { // 函数 fn func(a: i32, b: i32) -\u0026gt; i32 { a + b } // 闭包定义1 let func = |a: i32, b: i32| -\u0026gt; i32 { a + b }; // 闭包定义2: 省略类型标注 let func = |a, b| { a + b }; // 闭包定义3: 块内只有一个表达式时，省略大括号 let func = |a, b| a + b; // 闭包定义4: 使用 move let func = move |a, b| a + b; // 相同的调用方式 let res = func(1, 2); assert_eq!(res, 3); } 闭包捕获环境的方式 闭包如果需要捕获环境的话，方式有这几种（对应于函数参数定义的三种方式）：\n不可变引用 \u0026amp;T 可变引用 \u0026amp;mut T 移动语义（获取所有权） T 当在 || 前使用 move 时，将强制闭包以 移动语义（move） 捕获值，获取值的所有权。若捕获的值的类型实现了 Copy Trait ，则会使用 Copy 复制语义。\n当没有使用 move 时，编译器会按照如下顺序进行检查，选择捕获方式，直到遇到第一个能通过编译的选项：\n不可变引用 唯一不可变引用 可变引用 移动语义 此处，唯一不可变引用 是基于借用规则而出现的一种特殊的捕获方式。对于下述代码：\n1 2 3 4 5 6 7 8 9 10 11 let mut a = 0; let b = \u0026amp;mut a; { let mut x = || { *b = 1; }; x(); // 下行代码会导致编译错误 let y = \u0026amp;b; println!(\u0026#34;{y}\u0026#34;); } let z = \u0026amp;b; 代码中 b 是对 a 的可变借用，因此可以通过解引用 b 来修改 a 的值。但在这里我们将修改a的值的操作放在了闭包中，而这个闭包理所当然地使用了 b，因此闭包需要捕获它。\n由于 b 本身不是 mut 的，因此无法以可变引用的形式捕获。但若以不可变引用的形式捕获，那么就会获得对可变引用的引用 \u0026amp; \u0026amp;mut，这会导致可以存在多个可变引用（即不唯一的可变引用），这违反了借用规则。\n这时，闭包便使用被称作唯一不可变引用的特殊方式来捕获变量，即它会对 b 进行不可变引用，同时由编译器确保对 b 的引用只有一个。\n3种闭包Trait 这里需要做一区别，闭包如何捕获环境，和闭包如何使用捕获到的值，两者是不同的。\nRust编译器会根据闭包 如何使用 捕获到的值（将值返回，或不返回但修改，或不返回且不修改），来决定为闭包实现哪些闭包Trait。 或者说，编译器通过这3种Trait来描述和分类不同的闭包：\nFnOnce ：闭包可能会消耗掉捕获值的所有权，只能调用一次。（若消耗掉所有权则只能使用一次，故而所有的闭包均实现了该Trait。） FnMut ：闭包不会消耗掉捕获值的所有权，会对捕获值进行修改。 Fn ：闭包不会消耗掉捕获值的所有权，不会对捕获值进行修改。 所有闭包都 至少 实现了 FnOnce。Rust会渐进地为闭包实现一个，两个或全部的 trait。\n所有类型的闭包中，有些闭包可能会消耗掉捕获值的所有权，这种闭包在调用一次后无法再次调用（要处理的值已经不见了），因此对于所有的闭包来说，闭包最少是可以使用一次的。 如果闭包并不消耗掉捕获值的所有权，便可以多次被调用，它对捕获值的操作，只可能是修改或者不修改，前者使用 FnMut 描述，后者使用 Fn 描述。\n因此可以说，3种闭包Trait，是在 闭包如何使用捕获值的角度上，对闭包的分类。\n现在观察这3种Trait的定义签名（简化）：\n1 2 3 4 5 6 7 8 9 10 pub trait Fn\u0026lt;Args\u0026gt; : FnMut\u0026lt;Args\u0026gt; { extern \u0026#34;rust-call\u0026#34; fn call(\u0026amp;self, args: Args) -\u0026gt; Self::Output; } pub trait FnMut\u0026lt;Args\u0026gt; : FnOnce\u0026lt;Args\u0026gt; { extern \u0026#34;rust-call\u0026#34; fn call_mut(\u0026amp;mut self, args: Args) -\u0026gt; Self::Output; } pub trait FnOnce\u0026lt;Args\u0026gt; { type Output; extern \u0026#34;rust-call\u0026#34; fn call_once(self, args: Args) -\u0026gt; Self::Output; } 可以看到，实现 FnMut 的条件是，已经实现了 FnOnce（可以说FnOnce就代表了闭包），而实现 Fn 的条件是已经实现了 FnMut，因此，闭包对这3种Trait的实现有这三种情况：\n只实现了 FnOnce 实现了 FnOnce 和 FnMut 实现了 FnOnce ，FnMut 和 Fn 分别对应上述三种 trait 。\n函数式编程：作为参数和返回值 由于Rust中的闭包实现了上文介绍的几种闭包特征，因此可以使用特征约束的方法让闭包作为函数参数或返回值来使用，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 接收一个 FnOnce() 类型的闭包并调用 fn function\u0026lt;F\u0026gt; (f: F) where F: FnOnce() { f(); } // 返回一个 FnOnce() -\u0026gt; \u0026amp;\u0026#39;static str 类型的闭包 fn some_func() -\u0026gt; impl FnOnce() -\u0026gt; \u0026amp;\u0026#39;static str { || { \u0026#34;666\u0026#34; } } // 返回一个特征对象，不常用 fn dyn_func() -\u0026gt; Box\u0026lt;dyn FnOnce() -\u0026gt; \u0026amp;\u0026#39;static str\u0026gt; { Box::new(|| { \u0026#34;999\u0026#34; }) } 对于函数而言，只要符合特征约束，也可以作为其他函数的参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 将要接收函数和闭包作为参数的函数 fn call_me\u0026lt;F: Fn()\u0026gt;(f: F) { f() } // 一个函数 fn function() { println!(\u0026#34;I\u0026#39;m a function!\u0026#34;); } fn main() { // 一个闭包 let closure = || println!(\u0026#34;I\u0026#39;m a closure!\u0026#34;); call_me(closure); call_me(function); } 闭包的实际类型 当使用闭包表达式定义一个闭包时，编译器会隐式生成一个匿名结构体，闭包将要捕获的变量会作为该结构体的字段。同时，该结构体会根据闭包如何使用捕获的值（也就是结构体字段）选择实现哪种闭包Trait，由此就可以实现闭包的函数功能。 例如，对于以下闭包：\n1 2 3 4 5 6 7 8 9 10 fn closure\u0026lt;F\u0026gt;(f: F) where F: FnOnce() -\u0026gt; String { println!(\u0026#34;Closure return: {}\u0026#34;, f()) } fn main() { let hello = String::from(\u0026#34;Hello\u0026#34;); let s = || { hello }; closure(s); } 编译器会大致生成如下的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 struct ClosureSome { a: String, } impl FnOnce\u0026lt;()\u0026gt; for ClosureSome { type Output = String; fn call_once(self) -\u0026gt; String { self.a } } fn closure(f: ClosureSome) { println!(\u0026#34;Closure return: {}\u0026#34;, f()) } fn main() { let hello = String::from(\u0026#34;Hello\u0026#34;); let s = ClosureSome { a: hello } closure(s) } 因此每个闭包都具有自己独特的类型，且无法被写出。\n由此可以看出，当传递一个闭包时，传递的实际上是一个结构体，而调用一个闭包时，则是调用相应Trait定义的方法。\n上文中介绍了编译器根据闭包如何使用捕获到的值而实现不同的闭包特征，而对于 闭包没有捕获值 的情况，该闭包可以被 自动强转 为函数指针：\n1 2 3 4 5 6 7 8 9 fn main() { let add = |x, y| x + y; let mut x = add(5,7); type FnPointer = fn(i32, i32) -\u0026gt; i32; let p: FnPointer = add; x = p(5,7); } 总结 Rust中的闭包可以实现一些函数式编程的功能，它与函数类似，但也不同，主要便在于闭包可以捕获环境。\n闭包 捕获环境 的方式分为三种，即 \u0026amp;T \u0026amp;mut T 和 T，当闭包不捕获环境时，可以被自动强转为函数指针。\n闭包 使用捕获值 的方式也分为三种，即消耗所有权，不消耗所有权并进行修改，不消耗所有权且不修改。与此对应的，有三种闭包特征，即 FnOnce， FnMut 和 Fn，实现了后一个特征则肯定实现了前一个特征，如一个闭包实现了 Fn，它肯定实现了 FnMut 和 FnOnce。\n通过使用Trait Bound，利用3种Trai，可以将闭包作为参数传递，或作为返回值返回。\n最后，闭包实现这样一系列功能的背后，它的真实类型是一个编译器自动生成的匿名结构体，结构体的字段存储着闭包捕获的环境，编译器为它实现相应的Trait，并将闭包包含的语句和表达式作为具体的实现。\n","date":"2025-04-01T13:38:17+08:00","image":"https://blog.hizhixia.site/post/rust%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%97%AD%E5%8C%85/navigation_hu_28718a97406ca66c.jpg","permalink":"https://blog.hizhixia.site/post/rust%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B-%E9%97%AD%E5%8C%85/","title":"Rust的函数式编程— 闭包"},{"content":" 偶尔翻到四五年前写出的一些东西，能看出一些当时想要释放的情绪，不过都会被淹没的。\n一 三十岁的小伙儿老赵猛一下从床上起来。\n顾不上擦汗，如同一只跳起的青蛙快速爬到窗边，用力掀开那扇窗户。总算是觉得畅快了。\n他呼了几口气，看到从嘴里出来的气体变成了水雾，抖了抖身子细细感受后，才觉得这天越来越冷。这口雾从幽暗的嘴里呼出，慢慢升入不太蓝的天空，发光的太阳像被罩着灰布，时隐时现。他觉得与其说是天冷，倒不如说是心冷了，从里到外的冷冽才会让人这么难受，不然也不至于这几层棉睡衣也熬不住。\n也顾不上想那个噩梦，只是尽快换上衣服。时间不早了，平日里这时候，他已经在去上班的地铁上，跟其他赶工干活的人拥挤在一起，从一个不痛快的地方到另一个不痛快的地方。\n正要出门时，媳妇呵了他一声：要干撒去！\n只一愣，她立马把手机贴到老赵的脸上。细细一看，便觉得从胸腔里传出的那种冷冽更要害了。\n该死的！怎么连这鬼地方都要封。\n还没睡足的老赵把早餐，上班，服务，挣钱之类的字眼统统从脑子里揪出来，只扒掉了一层衣服就又钻进被窝。他很想这样一睡就不再起来了。\n然而偏偏这时候，就有刺耳的响动试图拽他下来。他细听，这声音从墙的外边来，穿透半米厚的钢筋混凝土，直冲冲地戳中他的脑仁，一会儿从左边响，一会儿从右边响，忽左忽右，忽远忽近。要不是声音连贯响起，他可能会以为这是一个人把自己撕成各两半，从两边连起来折磨他。\n刚要抱怨，这声音突然清晰了，“做何酸了，快出来做何酸，赶紧出来做何酸！”（这里并不是老赵不懂这两个音对应的什么字，只是因为这样他就可以把人和事儿一起骂个遍了）。于是老赵开始使劲地抱怨，“这急着就来赶驴上架，做，赶紧做，我老赵早晚有一天要给你这坏怂做一百次核酸！”\n老赵跟媳妇一起从床上掉下来，穿上两种不同的衣服，染上两种不同的烦躁，戴上两个一样的口罩，走过同一扇破败的门。\n在路上的时候，他想着，也许还不算烂吧，一辈子说不定就这样过去了。灵魂被牵引着从无尽黑夜来，又到无尽黑夜去，北方的来风给他着上一层外衣\u0026hellip;\u0026hellip;\n老赵正要诗兴大发，前面的大白让他张开嘴巴，他张开嘴啊啊地叫喊，被捅得却越来越用力。于是他跟着棉签的动向摇头晃脑。\n他感觉自己的嗓子像是嘶吼了几个钟头，脑子也有点晕乎乎的。路上有人对着自己窃窃私语，“你看这老赵的头，摇来摇去，好像个疯的”。于是老赵摇头晃脑地回话：亏你达！\n媳妇在旁边掐他一把，瓜怂，脸丢没了。老赵赶紧抓住媳妇的手往回走。\n回去以后，老赵摇了一天的头。\n二 某天之后，老赵一直蹲在家，不能出去，也不想出去。\n平日里，他总是向旁人抱怨，这觉是怎么也睡不够。如果上天给他时间，一定要趴在被子里拉展，睡得昏天黑地，一直睡到肚子里全是空的，饿得不行再醒过来往里填充。现在时间已经足够，而且足得很富裕，可老赵只睡了一天，就已经不愿想这睡觉的事情了。\n今天，他还是跟之前一样呆呆站在窗前。这个楼层看不见什么，隐约中有一道分界线，把面前茫茫的一片白分成两半，顶上的有些像透着塑料袋看的大海，下面则乱七八糟，混沌得就像铁锅里炖猪蹄。这个年纪不算老，或者说老赵正值壮年，大部分人也许能知道他正想着什么，这样的想法正出自很多青年口中。老赵也很清楚自己想的，无非是迷茫，道路，人生之类的话。可他怎么突然就觉得，自己已经是个老头了呢，莫非是老赵这个称呼喊多了？\n他需要出去一趟了。家里囤的食物已经不太多，剩下的撑着也能过个一两天，可谁知道什么时候才让自己出去呢？听说昨天又有几个得病的。\n他已经算好了时间，去做何酸的时间大概在下午两点，自己中午一点出去，买完东西直接去做，大约两点半就可以到家了——超市离家很近，本来打算一点半去的，为了时间宽裕，他打算早点去。\n老赵十二点半就出门了。无他，吃完饭闲着没事儿干，想着在可以趁这个机会好好溜达溜达。或许逃出那个方块似的房子，他脑子里的想法也会跟着拨云见日。\n超市门口排着队，好在排队的人不多，看长度也只有十米。老赵站进了队伍发呆。不一会儿，他就发现这队伍的前进速度实在很慢，脑子里已经放了两遍没有意义的歌曲，可他还在原地。莫非有人插队？迈出一步探头看去，他们都紧紧贴着前面的人，整齐地低着头，如果仔细看去倒也不算整齐，低的角度还不太一样。老赵忽然呛了一口，好像面前点了一圈干柴要知道这还是隔着口罩。他抬头看去，原来是前面的大高个儿在猛抽烟。高个儿的一只耳朵上戴了一整个口罩，手指撮着烟头，比银行家数钱还要抖擞，烟雾就从两个鼻孔和一张嘴里喷薄而出。还有两只耳朵，甚至眼睛里也冒出了烟雾。\n他心想，高个儿或许正在挣扎，同自己一样，于是也就紧了紧口罩，不再去管。无聊之中拿出了手机，翻看了一些无聊的文章和视频，时间也就在这之中消磨了。突然，他被人往前顶了一步，总算是进去两个人。老赵打开备忘录，打算看看自己准备的购物清单，但手机却卡住了，屏幕不再变化。他使劲播弄了几下，原来是电话打进来了。刚接上，一声怒吼就从话筒里喷出来，就像是岩浆要钻进他的耳朵：烂怂老赵等你半天，赶紧回来做何酸！\n竟然已经两点了。老赵看着自己在排的队，前面的人还是那么的多，回头看去，自己后面已经跟了好几十人。不，在老赵眼中有几百人几千人。他有些头晕，自己的视线被猛然拉长数倍，他看到前面的人离自己越来越远，于是赶忙向前一冲。忽然前面的人又很快地靠近自己，像一块陨石正要砸在自己的面门，于是又响后一退。老赵在恍恍惚惚中滚出了队伍。拍了一下额头，仔细一看，这哪是什么队伍，分明是一条正在蠕动的长虫！\n他赶着小跑，仓皇逃到楼下，看到居民正在排队，立马扎了进去。老赵听到楼上又有人在喊：做何酸了，快出来做何酸，赶紧出来做何酸！这时前面拿喇叭的居委会某委员也跟着喝起来：间距一米赶紧站开，快快快！老赵不敢懈怠，立马照做。他又跟着队伍走，到了最终要做的地方。这时前面拿喇叭的大白喊起来：麻烦大家，间距一米站开\u0026hellip;\u0026hellip;\n老赵心里嘀咕，之前不是站过了吗？他也不想麻烦别人，立马照做，朝后直退了半条大街，整个队伍才站成一米的间隔。\n回家之后，老赵又摇了一整天。\n","date":"2025-04-01T13:37:48+08:00","image":"https://blog.hizhixia.site/post/%E5%86%AC%E8%87%B3/navigation_hu_eddc34c32264e88b.jpg","permalink":"https://blog.hizhixia.site/post/%E5%86%AC%E8%87%B3/","title":"冬至"},{"content":" 3月的最后一天凌晨，在压抑的情绪中所写的推文。\n最近几年我对事物的态度变了很多，最初是热情激进，之后是麻木冷淡，再到现在乱七八糟的各种情绪杂糅在一起，复杂且混乱。 在那之前我应是富有想象力的，能在期待的井里幻想出一整片天。然后发现我并没有能够撬动世界的杠杆，哪怕是改变它某一部分的能力都没有。或许杆太脆弱了，或许我太轻了。\n现在的我则是在后悔和摆烂的阴雨一样的日子里反复发酵的无意义烂木头。我总是在做完事之后发现有更好的方法，会有更好的结果。而我惧怕，怯懦于做事的不完美，社交的尴尬，行动的考虑不周。于是需要做事时我畏惧，需要学习时我忧虑，进而我恐慌能让我进步的一切。\n我害怕，于是我变得“洒脱”随意，他们喊我随波逐流或随遇而安。事实上我远离了生活，可能还有本要燃烧的生命。我告诉朋友我的秘密，放弃摆在眼前的机会，忘记知识和回忆，停止思考。 偶尔某时不知如何被惊醒，只觉得一些事本不该是这样的。但灵感都需要一些土壤，而我只是凭空的臆想。\n本来觉得一切并无所谓，奈何我变得如此脆弱，常常觉得委屈，变得喜欢流泪。何来委屈，皆是自取，只是偶尔因为某些小事得不到应有的待遇而委屈，也因此只敢躲在床上偷偷地哭。我喜欢哭时的心酸，让我感觉我还不彻底麻木，我还是有真实的情感的人。能真实地爱和恨？起码能真实地哭。\n我一日的情绪常在后悔，忧伤，放荡和彻底的空洞之间变换。但它们中间还有偶尔的幸福喜悦和轻松。 我因浅薄的阅历，稀少的知识，贫瘠的身资，失去了能装满太平洋的那么多东西。但我还有很多小小的好东西，就在我的手边。它们小小的，我力气再小也能握住，而且只要我握紧，是不会丢掉的。\n","date":"2025-04-01T13:06:18+08:00","image":"https://blog.hizhixia.site/post/%E8%A7%A3%E6%9E%84%E4%B9%8B%E4%B8%80/navigation_hu_f62d9f187b0f54e8.jpg","permalink":"https://blog.hizhixia.site/post/%E8%A7%A3%E6%9E%84%E4%B9%8B%E4%B8%80/","title":"解构之一"},{"content":"忧伤的色彩如油画一般。\n草儿长满山丘 草儿长满山丘，\n深蓝下嫩绿的一片\n红或黄的鲜艳零碎，\n分离散落着，\n让情绪饱和得柔乱\n\u0026nbsp;\n山风抚荡裙摆，\n点多溶作一系青岚\n某些与某些坐着，\n蓝色的幽暗水滴，\n绽在清澈的池中为伴\n\u0026nbsp;\n散落的花瓣捡起，\n轻轻触摸，\n眼中映出的霜英破败\n能否似这野芳模样，\n倘我能拥抱它的忧伤，\n可我似野芳一样\n\u0026nbsp;\n微风从岩石处涌来\n从山丘到峡谷，森林或海洋\n经过光的瘀伤，\n淌过溶解的月亮，\n流浪\n","date":"2025-03-29T15:07:31+08:00","image":"https://blog.hizhixia.site/post/%E8%8D%89%E5%84%BF%E9%95%BF%E6%BB%A1%E5%B1%B1%E4%B8%98/navigation_hu_192c3794f42ff5c6.jpg","permalink":"https://blog.hizhixia.site/post/%E8%8D%89%E5%84%BF%E9%95%BF%E6%BB%A1%E5%B1%B1%E4%B8%98/","title":"草儿长满山丘"},{"content":"进制表示法 计数时为了方便表示大的数量，因此采用进制表示法计数。\n#n进制计数法\n$n$ 进制计数法 代表的意思有：\n数到第 $n$ 个数就进位（如：0, 1, 2, 3, 4, 5, 6, 7, 8, 9，9是第十个数，数下一个数时就会进一位，即10。） 一共只有 $n$ 个不同的符号（比如十进制只有0到9，共10个数字。二进制只有0和1，共2个数字。） 一个数位上的数字可以选取 $n$ 个值，例如某个十进制表示数的个位可能取0到9这十个种的任意一个，有10种可能。 因此，一个n进制表示数如果有1位，则有 $n$ 种可能。有2位，则有 $n \\times n = n^2$ 种可能，以此类推，如果有 $x$ 位，则有 $n \\times n \\times \u0026hellip;\u0026hellip; \\times n = n^x$ 种可能。 也即，$x$ 位的 $n$ 进制表示数一共可以表示 $n^x$ 个数。比如一个2位的10进制数，可以表示从0到99一共100 ($10^2=100$)个数，一个4位的2进制数，可以表示从0到 1111 共 16 ($2^4=16$)个数。 #多个数位的产生\n在计数时，满了n就进一位，意思是着这时一位能表示的数字已经表示完了（n进制的n个数字已经用完了），所以才会 多用一位 来表达。比如数某个东西的数量，使用十进制，先用一位数，数到9时，已经不能表示更多了，所以多加一位来表示，这时就会进位，变成一个2位数 10。这时继续计数，到19时，个位又不能表示更多了，于是继续进位，变成20。当数到99时，这时个位不能表示更多，发生进位，十位也不能表示更多，于是继续进位，此时就会有三位的数字了。\n#通用一些的表示\n可以看出来，一位数每一位表示1个数字，一共能表示10个数字，而两位数中的十位是个位表示完它能表示的十个数字之后进位产生的，因此一个两位数的十位表示10个数字。比如一个两位数63，它表示的实际数量是$6\\times{10}+3$。 这里的 “个位十位” 的称呼是十进制专属的，对于所有进制表示法，一般用 “第0位，第1位” 表示。同时，每一位数字的值用 $d_0, d_1, \u0026hellip;$表示。 例如，十进制数字 $234$ 的第0位数字 $d_0=4$，第一位数字 $d_1=3$，第二位数字 $d_2=2$ 。\n以此类推，n进制表示法中，第0位数字表示的实际数量是 $d_0$，第1位数字表示的实际数量是 $d_1 \\times{n}$ ，第2位数字表示的实际数量是 $d_2\\times{n}\\times{n}$ 。\n#通用表示（按权展开）\n现在得到通用的表示，在 $n$ 进制表示法中，用 $D$ 表示一个数字表示的实际数量，则对于任意一个 $m$ 位的数字来说，都有: $$ D = d_m\\times{n^m} + d_{m-1}\\times{n^{m-1}} + \\dots + d_2\\times{n^{2}} + d_1\\times{n^{1} + d_0\\times{n^0}} $$\n因为我们是使用十进制进行计数的，我们使用的加法和乘法以及乘方都是十进制的，包括上面这个通用表示在描述时也是使用十进制表示实际数量的。\n#转换为十进制 所以对于任何一个n进制数，带入该通用表示 即可得到它表示的 十进制数的实际数量。\n#转换为任意进制 如果我们在这个通用表示中使用的是n进制，那我们只要使用n进制的数字表示，加法，乘法和乘方，那么我们只要带入该通用表示，就可以得到任何表示法表示的n进制数的实际数量。\n进制转换 转换为十进制 因为我们使用的就是十进制，所以先学习通用表示法转换为十进制：\n#二进制转换为十进制\n二进制100111 转十进制39： $$ D= 1 \\times 2^5 + 0 \\times 2^4 + 0 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 32 + 0 + 0 + 4 + 2 + 1 = 39_{10} $$ ​ #八进制转换为十进制\n八进制124 转十进制84： $$ D = 1 \\times 8^2 + 2 \\times 8^1 + 4 \\times 8^0 = 64 + 16 + 4 = 84_{10} $$\n#十六进制转换为十进制\n十六进制3E8₁₆ 转十进制1000： $$ D = 3 \\times 16^2 + 14 \\times 16^1 + 8 \\times 16^0 = 768 + 224 + 8 = 1000_{10}​ $$\n转换为n进制 这里首先介绍使用的是 通用表示法，假设我们要将 n 进制数转换 m 进制数，为使用通用表示法，首先要求 我们能把n进制表示法的n个数字以及这个n，用m进制表示（比如十进制转换为二进制时，需要知道0到10的二进制表示）。\n不要问为什么十进制表示法没这个要求，因为我们已经能把二进制，八进制，十六进制以及许多其他进制用十进制数字表示了 0v0 。回头看看上方通用表示法下面的 #转换为任意进制 的说明。\nTips: n进制的乘法可以使用竖式计算（各位相乘，各行累加，进位）\n以下为一个通用表示法的示例，由于要转换为m进制，就要学习n进制的乘法对于人来说比较麻烦，因此只做演示。 但对于常用的 二进制和十进制的转换 来说，已经足够了。\n#十进制转换为二进制\n#通用表示法（按权展开）\n十进制数39转换为二进制100111（0到10的二进制表示在文尾）： $$ D = 11 \\times 1010^{1} + 1001 \\times 1010^{0} = 11110 + 1001 = 100111_2 $$\n另一种十进制转换为二进制的方法是 除以2取余法，即十进制数除以2，然后取其余数（只可能是1或0）作为低位，逐步相除排列直到商为0时停止。\n#除以2取余法\n还是十进制数39： $$ 39 \\div 2 = 19 \\dots 1 $$ $$ 19 \\div 2 = 9 \\dots 1 $$ $$ 9 \\div 2 = 4 \\dots 1 $$ $$ 4 \\div 2 = 2 \\dots 0 $$ $$ 2 \\div 2 = 1 \\dots 0 $$ $$ 1 \\div 2 = 0 \\dots 1 $$\n排列余数，得100111 。\n二、八、十六进制的转换 很显然 8 和 16 分别是 $2^3, 2^4$，结合前面所说的，可以知道八进制的一位可以表示的实际数量需要二进制的三位来表示，十六进制的一位则需要用二进制的四位来表示。因此它们可以很方便地与二进制互相转换。\n这种方便在于，碰到比较长的数字时，转换起来比十进制的转换更快更 解压 。\n#二进制与十六进制\n因为1位十六进制需要用4位二进制表示，当你大概记得一些十六进制数字的二进制表示时，你会很快地得到转换结果。 比如：\n二进制10 1001 0111 1010 1011转换为十六进制：冒号后面没啥步骤了，直接按顺序写出来是 297AB 。\n十六进制3F8A转换为二进制：11 1111 1000 1010 。\n八进制也是同理。\n二进制与十六进制转换表 二进制 (4-bit) 十六进制 (Hex) 十进制 (Dec) 0000 0 0 0001 1 1 0010 2 2 0011 3 3 0100 4 4 0101 5 5 0110 6 6 0111 7 7 1000 8 8 1001 9 9 1010 A 10 1011 B 11 1100 C 12 1101 D 13 1110 E 14 1111 F 15 ","date":"2025-02-20T00:40:47+08:00","permalink":"https://blog.hizhixia.site/post/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/","title":"进制转换"},{"content":"Rust的 Clap Crate 非常适用于开发命令行程序，它是一个“简单易用、高效且功能齐全的命令行参数解析器”。\nClap的作用在于帮助我们定义命令行工具的各种指令和用法，并解析用户使用的什么指令。之后我们只需要编写对应指令的功能代码即可。\n在这里简单记录一下它的一些用法。\ncrates.io: link docs.rs: link repo: link Exapmles: link 本文编写时：\n1 clap = \u0026#34;4.5.29\u0026#34; Clap的两种API Clap目前可以使用这两种方式构建命令行程序：\nBuilder API Derive API 官方的example多数都提供了两种方式的示例。 若要使用Derive API，记得要添加feature：\n1 clap = { version = \u0026#34;4.5.28\u0026#34;, features = [\u0026#34;derive\u0026#34;] } 两种构建方式的区别主要是：\nBuilder API\n链式调用的方式构建程序。 由于是 链式调用，代码 很长很复杂，可复用度较低。但在命令行参数需要经常变动调整时比较方便，加减几个函数调用就行。 Derive API\n声明式，通过定义命令和参数对应的 Strut 和 Enum 并在上面使用 属性宏 构建程序。 使用 声明式 构建，代码 直观简洁，方便理解和维护。适合参数和命令比较稳定的命令行程序。 使用 Derive API 可以兼顾开发效率和可维护性，同时上手方便。如果有复杂定制或控制更多细节的需求，再使用Builder API。 在特定情况下，Derive 和 Builder API 可以混合使用： Mixing Builder and Derive APIs\n使用方式 官方给的Git示例比较好，推荐查看：\ngit-Builder API git-Derive API Builder API Builder API 下，我们需要创建一个Command，通过调用 get_matches()函数来解析参数并获得 ArgMathces，然后对它进行模式匹配解析出相应指令，最后编写其对应的功能代码完成程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 use clap::{Command, arg, Arg}; fn main() { let cmd = Command::new(\u0026#34;CLI Name\u0026#34;) .version(\u0026#34;1.0\u0026#34;) .author(\u0026#34;Name \u0026lt;email@email.com\u0026gt;\u0026#34;) .about(\u0026#34;Introduction\u0026#34;) .subcommand_required(true) // 位置参数 .arg( Arg::new(\u0026#34;input\u0026#34;) .help(\u0026#34;文件路径\u0026#34;) .required(true) ) // 选项参数 .arg( Arg::new(\u0026#34;name\u0026#34;) .short(\u0026#39;n\u0026#39;) .long(\u0026#34;name\u0026#34;) .help(\u0026#34;指定用户名\u0026#34;) .arg_required_else_help(true) ) // 定义子命令 .subcommand( Command::new(\u0026#34;diff\u0026#34;) .about(\u0026#34;比较两个文件\u0026#34;) .arg( Arg::new(\u0026#34;full\u0026#34;) .help(\u0026#34;全文比较\u0026#34;) .long(\u0026#34;full\u0026#34;) ) .arg( Arg::new(\u0026#34;info\u0026#34;) .help(\u0026#34;比较文件信息\u0026#34;) .long(\u0026#34;info\u0026#34;) ) ) ); let matches = cmd.get_matches(); // 匹配参数 let input = matches.value_of(\u0026#34;input\u0026#34;).unwrap(); println!(\u0026#34;输入文件: {}\u0026#34;, input); if let Some(name) = matches.value_of(\u0026#34;name\u0026#34;) { println!(\u0026#34;用户名: {}\u0026#34;, name); } else { println!(\u0026#34;未指定用户名\u0026#34;); } // 匹配子命令 match matches.subcommand { Some((\u0026#34;diff\u0026#34;, diff_matches)) =\u0026gt; { let full = diff_matches.get_one::\u0026lt;String\u0026gt;(\u0026#34;full\u0026#34;).map(|s| s.as_str()); TODO(\u0026#34;这里还是看官方Example好一些\u0026#34;); } } } Derive API Derive API 下，我们需要创建一个结构体表示命令行程序，随后可以向其中嵌套添加结构体或枚举表示子命令、参数等：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 use clap::Parser; #[derive(Parser)] #[command(next_line_help = true)] #[command(name = \u0026#34;hello\u0026#34;, version = \u0026#34;1.0\u0026#34;, about = \u0026#34;一个简单的示例程序\u0026#34;)] struct Cli { // Option\u0026lt;T\u0026gt; 表示可选参数 name: Option\u0026lt;String\u0026gt;, // 表示包含子命令。子命令定义在Commands枚举中 #[command(subcommand)] command: Commands, } #[derive(Subcommand)] enum Commands { #[command(about = \u0026#34;A subcommand\u0026#34;)] A, #[command(about = \u0026#34;B subcommand with args\u0026#34;)] B(BArgs), } #[derive(Args)] struct BArgs { // 定义参数，value_enum 表示该参数的值是可选的几个给定值 #[arg(short, long, required = true, value_enum)] #[arg(help = \u0026#34;Info mode\u0026#34;)] mode: BArgsMode, } #[derive(Copy, Clone, ValueEnum)] enum InfoFaArgsMode { #[value(help = \u0026#34;aa\u0026#34;)] AA, #[value(help = \u0026#34;aa\u0026#34;)] BB, } fn main() { let args = Cli::parse(); // 匹配可选参数name let name = args.name.unwrap(); //匹配定义的command 子命令 match args.command { Commands::A =\u0026gt; { TODO() }, Commands::B(args) =\u0026gt; { TODO() }, }\t} 常用配置 参数和子命令的一些设置 位置参数 结构体中不加 #[arg(short, long)] 时默认作为位置参数。位置参数可以直接使用： 1 my-app my_arg 选项参数 使用 #[arg(short, long)] 时作为选项参数，用户可以通过短选项（如 -n）或长选项（如 --name）传递参数： 1 my-app -a arg --barg arg 标志参数 当值的类型为布尔值时如 debug: bool 为标志参数，出现即为true,未出现为false。一般出现时与action联用（ #[arg(short, long, action = clap::ArgAction::Count)]）： 1 my-app --debug 对Command的配置 name version author about / long_about propagate_version 如果设置为 true，子命令也会显示顶级命令的版本信息。 #[command(propagate_version = true)] disable_help_flag / disable_version_flag 禁用时不会自动生成 --help 和 --version。 next_line_help 设为true时，帮助信息将会显示在命令名称的下一行。 term_width 指定帮助信息的输出宽度，便于美化输出。 #[command(term_width = 80)] allow_external_subcommands help_template 自定义帮助信息模板，如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #[derive(Parser)] #[command( about = \u0026#34;帮助信息定制示例\u0026#34;, help_template = \u0026#34;\\ {name} {version} {about} USAGE: {usage} {all-args} \u0026#34;, term_width = 80 )] 对subcommand的配置与此类似。\n对Args的配置 short 和 long 设置参数的短选项和长选项。 示例：#[arg(short, long)]（自动推导名称），也可以显式设置：#[arg(short = 'n', long = \u0026quot;name\u0026quot;)] help value_name 指定参数在帮助信息中显示的值名。 示例：#[arg(value_name = \u0026quot;FILE\u0026quot;)] default_value / default_value_t 设置默认值，可以是字符串或类型 T 的默认值。 示例：#[arg(default_value = \u0026quot;8080\u0026quot;)] 或 #[arg(default_value_t = 8080)] required / required_if / required_if_eq 控制参数是否必填，或在某些条件下必填。 示例：#[arg(required = true)] 或 #[arg(required_if_eq(\u0026quot;mode\u0026quot;, \u0026quot;a\u0026quot;))] env 没有输入参数时将从设定的环境变量中读取值作为该参数。 #[arg(env = \u0026quot;MYAPP_CONFIG\u0026quot;)] value_parser 设置参数的解析器，可以指定类型转换、范围限制或自定义验证函数。 示例：#[arg(value_parser = clap::value_parser!(u16).range(1..=65535))] action 针对布尔值或计数参数，可以指定行为，例如 Count（出现一次该参数则值增长1）或 SetTrue（只要参数出现出现就设为 true）。 #[arg(short, long, action = clap::ArgAction::Count)] conflicts_with / requires 用于定义参数之间的互斥或依赖关系。 示例：#[arg(conflicts_with = \u0026quot;other_arg\u0026quot;)] 或 #[arg(requires = \u0026quot;config\u0026quot;)] group 为参数设置组，同一个组的参数有一个被输入即可。 #[arg(group = \u0026quot;input\u0026quot;)] alias / short_alias / long_alias ","date":"2025-02-12T20:40:22+08:00","image":"https://blog.hizhixia.site/post/clap%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/navigation.svg","permalink":"https://blog.hizhixia.site/post/clap%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/","title":"Clap的一些用法"},{"content":"Git真的是非常重要了！！但我编码不多，用到Git的场景也很少，一段时间不用就会忘掉好多命令和用法QwQ。\n按照一般的工作流记录一遍使用Git的工作流（顺便水一篇blog），顺便当个备忘录或教程（？），不要再忘了！\n配置Git 安装Git后，首先需要设置是谁在这台设备上使用Git工作，给自己注册个身份证：\n1 2 3 4 5 git config --global user.name \u0026#34;Name\u0026#34; git config --global user.email \u0026#34;Email@email.com\u0026#34; # --global 选项为用户级配置，在当前用户目录下(~)生成 .gitconfig # --system --local 分别为机器级配置和仓库级配置 # 分别生成在\tgithome 和 repo 下 为了方便使用Github或其他Git服务器，我们需要配置SSH。为防止冒名顶替可以配置GPG：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ssh-keygen -t ed25519 -C \u0026#34;your_email@example.com\u0026#34; # 若不支持 ed25519 则使用如下命令 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; gpg --full-generate-key # 若版本过旧使用如下命令 gpg --default-new-key-algo rsa4096 --gen-key # 查看现有的GPG密钥 gpg --list-secret-keys --keyid-format=long # 在Git中设置自己的私钥ID git config --global user.signingkey SEC_key_id git config --global commit.gpgsign true # 导出公钥 gpg --armor --export SEC_key_id 一些方便的命令 ^w^ ：\n1 2 3 4 5 6 7 8 9 10 11 # 更改git打开的文本编辑器 git config -- system core.editor vim # 长命令简写 git config -- global alias.diy_name_here command_here # 一条输出好看commit log的简写命令 git config -- global alias.loog log --color --graph --pretty=format:\u0026#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u0026lt;%an\u0026gt;%Creset\u0026#39; --abbrev-commit # 手动编辑config文件 git config -- global --edit 本地操作 要管理我们的项目，首先得创建一个Git库：\n1 2 3 4 5 git init my_proj # or mkdir my_proj cd my_proj git init 从头开始开发，先编写一些项目的配置文件，然后提交，作为最初的版本：\n1 2 3 4 5 6 7 8 9 # 添加所有文件到Stage git add . # 将内容从Stage提交 # -m \u0026#34;message\u0026#34; 选项附带简短的提交消息 git commit # 将当前Stage的内容合并到最近一次的提交，同时修改提交的message git commit -m \u0026#34;message\u0026#34; --amend 之后可以新建一个分支，在该分支上继续开发任务：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 查看当前仓库分支 git branch # 新建分支 git branch dev # 切换到新分支（两条效果相同） git switch dev git checkout dev # 可以用以下表示新建并切换到新分区 git switch -c dev git checkout -b dev # 修改分支名 git branch -M old_name new_name # 或修改当前分支 git branch -M new_name 现在看看在开发时怎么进行版本管理（）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 # 查看commit记录 # --pretty=oneline 选项简化输出每行显示一条commit # --oneline 选项简写commit id # -- file_here 选项显该文件相关的commit # --graph 选项图形化显示分支信息 git log # 查看当前仓库的状态 git status # 查看所有操作日志 git reflog # 若有文件被修改，查看工作区和Stage的差异 git diff file_name_here # 查看工作区或Stage与当前HEAD指向版本的差异 git diff HEAD -- file git diff HEAD --cached # revert 用于撤销指定commit的更改，并为此次撤销创建commit应用到当前分支 git revert commit_id_here # reset 用于回退到之前的版本 # HEAD^n 表示上n次提交 # --hard 已提交状态（删除工作区修改） --soft 未提交状态 --mixed 已添加未提交状态（） git reset --hard HEAD^ git reset --hard commit_id_here # 撤销*Stage*中已add的文件，保留工作区中的修改（不改变工作区） git restore --staged file # 与上条效果相同 git reset HEAD file # 撤销*Stage*中已add的文件，并撤销工作区中的修改使其与HEAD（若Stage中存在，则是Stage）一致 git restore file # 与上条命令效果相同 git checkout -- file # 删除文件 rm file git add. # 与上条效果相同 git rm file # 用于选取一次commit合并到当前分支 git cherry-pick commit_id # tag 用于为特定commit添加标签，可用于发布版本 # 当前命令为HEAD指向的commit添加标签 git tag tag_here # 为指定commit添加标签 git tag tag_here commit_id_here # -a 指定标签名 -m 指定标签说明 git tag -a tag_here -m \u0026#34;message\u0026#34; commit_id_here # 撤销打上的标签 git tag -d tag_here # 查看所有标签 git tag # 查看特定标签信息 git show tag_here 在该分支上完成开发任务后，可以合并到master分支：\n1 2 3 4 5 6 7 8 9 10 11 12 git switch master # 合并分支 # 默认 Fast-forward模式 合并 git merge dev # 合并后可删除分支 git branch -d dev # 如果分支在合并时太乱，可以Rebase成一条线 git rebase # 显示图形化的分支信息 git log --graph 协作开发 在本地使用Git进行版本管理进行得差不多了，现在看看如何使用Git借助远程仓库与别人协助工作。\n首先看看怎么进行远程仓库的一些相关操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 查看当前仓库的远程仓库信息 git remote -v # 为本地仓库添加远程仓库 git remote add remote_name remote_repo_uri # 推送选定分支到远程仓库 # --tags 选项推送本地所有tag git push remote_name branch_name # 将远程仓库作为选定本地分支的上游，简化push git push -u remote_name branch_name # 从远程仓库拉取 会merge到工作区 git pull remote_name # 从远程仓库拉取 只拉取仓库，不改变工作区，需要手动merge git ferch remote_name # 删除当前仓库和远程仓库的绑定信息 git remote rm remote_name # 从已有的远程仓库开始开发 git clone remote_name 多分支下与远程仓库的操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 查看远程仓库的分支 # -a 选项查看本地和远程的所有分支 git branch -r # 创建分支 # 将本地分支推送到远程。远程若没有则会创建 # -u 选项将绑定upstream，简化push git push remote_name branch_name # 一次推送本地所有分支 git push --all remote_name # 在本地创建分支，并与已存在的远程仓库关联 git checkout -b branch_name remote_name/remote_branch # 删除远程分支 git push remote_name --delete branch_name # 删除本地分支 git branch -d branch_name Patch和Submodule Patch用于记录代码的更改及应用，可以使用它生成最近几次的commit记录的patch，也可以很方便地把patch的改动合并：\n1 2 3 4 5 6 7 8 9 10 11 # 生成patch # 通过最近的n次commit生成n个patch git format-patch -n # 应用patch，但不会生成新的commit git apply patch_name.patch # 应用patch，但会生成新的commit git am patch_name.patch # 可使用send-email发送patch git send-email --to=\u0026#34;email\u0026#34; patch_name.patch Submodule用于管理大型项目，尤其是一个项目是由多个子项目构成时。例如Rust开发中使用 workspace 与 submodule 配合进行项目管理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 添加submodule # 添加本地的git仓库 git submodule add ./submodule_name # 添加远程仓库 git submodule add url submodule_path # 克隆带有 submodule 的仓库 git clone --recurse-submodules repo_url # 或克隆仓库后再获取submodule git submodule update --init --recursive # 为子模块commit后，包含它作为submodule的仓库也需要提交commit # submodule的远程仓库更新后，拉取最新代码 git submodule update --remote # 若只需要更新某个子模块 cd module_name git pull cd .. git add . \u0026amp;\u0026amp; git commit -m \u0026#34;message\u0026#34; # 删除submodule git submodule deinit -f module_name git rm -f module_name rm -rf .git/modules/module_name git commit -m \u0026#34;message\u0026#34; ","date":"2025-02-08T20:25:00+08:00","image":"https://blog.hizhixia.site/post/%E5%86%8D%E5%AD%A6%E4%B8%80%E9%81%8Dgit/navigation_hu_6954e3234d2e2710.png","permalink":"https://blog.hizhixia.site/post/%E5%86%8D%E5%AD%A6%E4%B8%80%E9%81%8Dgit/","title":"再学一遍Git"},{"content":"青春对我来说是一种自由的感觉。从以前到现在，社会身份逐渐自由，思想灵魂逃离自由。\n阴着却明亮的天，微凉的轻轻荡漾的风，在几棵柳树或橡树所在的地方，或跑或跳。 以前这样的场景最能使我的情绪激荡，当时仅靠环境就可以对情绪施加各样的压力，产生各种奇妙的感觉。而现在少有这种感觉了，或许是我的情绪本身不再敏感，或许是有更大的压力使我来不及感受，或许二者都有。\n最近某天我在一处公园的草地上散步，一不小心摔在了地上。 我趴在草坪上懵逼，脑子空空的，可能是闻到了草或泥土的味道（也肯定没闻到一些脏脏的味道），我没有着急起来，而是翻了个身继续躺。 我似乎捕捉到了以前有的某些感觉。但它来得很短暂，周围人聊天话语中一些破碎的字词让我想到一些关于生活或生存的事情，让我从地上拾起来。\n我现在理应拥有使用我身体以及让它进行一切行为的自由，但我的思想却不再能支配它们的自由了。\n","date":"2025-02-08T02:18:14+08:00","image":"https://blog.hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E8%87%AA%E7%94%B1/flower1_hu_6bccffe159e6af08.jpg","permalink":"https://blog.hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E8%87%AA%E7%94%B1/","title":"许多日前的自由"},{"content":"坐在电脑前神游时无意翻到了以前不知何时写的一些文字。\n今日来看往日，全是发疯，不过闲时看着倒是有些意思。随便找些搬运过来，刚好填补下空空如也的Blog。 还有许多自己拍的觉得有些意思的图，拿来当封面，这样看起来不至于很单调 ( .\n晚安 我正处在一处狭小的空间中，并不算好的环境和生活中的一些压力让我有些压抑。 但这时是夜，声音是寂静，颜色是望不到头的黑，我的情绪便能很好地融入在夜里。 也有不似白日里太阳的光，没有活力，冷冷地静止或移动。\n夜使我的忧郁或激昂看起来像是冷静，即使我知道这只是另一种疲倦。 我时而疲倦地叹息，时而疲倦地瘫坐，直到我忘记疲倦。 我不能走完完整的疲倦的夜，我不愿看它变成另一种无味，于是用睡眠来跨过夜的尸体，同时也让我如它一样无味。\n我记住梦前的晚安的话语，当作我梦中的幸运符，我在自己入睡前寄托所愿。 夜如此激发人的本能，希望传承的遗产。尽管这样，它仍使我安慰，它能带来安全的，温柔的睡和梦。\n今天的我还是不够好啊，所以，晚安。 明天的另一个我会怎么样呢，所以，晚安。 今天的自己将随夜留在今天，所以将最后的温柔带给自己，晚安！\n","date":"2025-02-08T01:13:35+08:00","image":"https://blog.hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E6%99%9A%E5%AE%89/navigation_hu_6e80257c9fb2094e.jpg","permalink":"https://blog.hizhixia.site/post/%E8%AE%B8%E5%A4%9A%E6%97%A5%E5%89%8D%E7%9A%84%E6%99%9A%E5%AE%89/","title":"许多日前的晚安"},{"content":"Hello World Welcome to my Blog !!!\nIt was built with Hugo and the theme \u0026ldquo;Stack\u0026rdquo;.\n","date":"2025-01-30T13:30:00+08:00","image":"https://blog.hizhixia.site/post/hello-world/cover_hu_843e06473c5bb246.jpg","permalink":"https://blog.hizhixia.site/post/hello-world/","title":"Hello Wrold"}]